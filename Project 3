# climate_model.py
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.seasonal import STL
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from sklearn.metrics import mean_squared_error, mean_absolute_error
import math

# 1. Load data (replace with your file path)
df = pd.read_csv("temperature_anomaly_monthly.csv", parse_dates=["date"])
df.set_index("date", inplace=True)
ts = df['anomaly'].asfreq('MS')  # monthly start

# 2. STL decomposition
stl = STL(ts, period=12, robust=True)
res = stl.fit()
trend = res.trend
seasonal = res.seasonal
resid = res.resid

# 3. SARIMA on trend+residual? We'll model the original with seasonal ARIMA
sarima_order = (1,1,1)
seasonal_order = (1,1,1,12)
model = SARIMAX(ts, order=sarima_order, seasonal_order=seasonal_order, enforce_stationarity=False, enforce_invertibility=False)
res_sarima = model.fit(disp=False)

# Forecast next 12 months with SARIMA
n_forecast = 12
sarima_forecast = res_sarima.get_forecast(steps=n_forecast).predicted_mean

# 4. LSTM on residuals to capture nonlinear part
# Prepare residual series for LSTM
resid = resid.dropna()
scaler = MinMaxScaler()
resid_vals = scaler.fit_transform(resid.values.reshape(-1,1))

# create sequences
def create_seq(data, seq_len=12):
    X, y = [], []
    for i in range(len(data)-seq_len):
        X.append(data[i:i+seq_len])
        y.append(data[i+seq_len])
    return np.array(X), np.array(y)

seq_len = 12
X, y = create_seq(resid_vals, seq_len)
split = int(0.9*len(X))
X_train, X_val = X[:split], X[split:]
y_train, y_val = y[:split], y[split:]

# build LSTM
model_lstm = Sequential([
    LSTM(32, input_shape=(seq_len,1)),
    Dense(1)
])
model_lstm.compile(optimizer='adam', loss='mse')
model_lstm.fit(X_train, y_train, epochs=40, batch_size=16, validation_data=(X_val,y_val), verbose=0)

# forecast residuals iteratively
last_seq = resid_vals[-seq_len:].reshape(1, seq_len, 1)
resid_forecast_scaled = []
cur_seq = last_seq.copy()
for _ in range(n_forecast):
    pred = model_lstm.predict(cur_seq, verbose=0)[0,0]
    resid_forecast_scaled.append(pred)
    # roll
    cur_seq = np.roll(cur_seq, -1, axis=1)
    cur_seq[0,-1,0] = pred

resid_forecast = scaler.inverse_transform(np.array(resid_forecast_scaled).reshape(-1,1)).flatten()

# 5. Combine forecasts
combined_forecast = sarima_forecast.values + resid_forecast

# 6. Output
future_index = pd.date_range(start=ts.index[-1] + pd.offsets.MonthBegin(), periods=n_forecast, freq='MS')
forecast_df = pd.DataFrame({'sarima': sarima_forecast.values, 'resid_pred': resid_forecast, 'combined': combined_forecast}, index=future_index)
print(forecast_df)

# 7. Evaluate on a holdout if available (not shown)
